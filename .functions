#!/bin/bash

# Always list directory contents upon 'cd'
cd() {
    builtin cd "$@" || return
    if [[ -n "${DOTFILES_CD_SKIP_LISTING:-}" ]]; then
        return
    fi
    ls
}

# mcd: Makes new Dir and jumps inside
mcd () { mkdir -p "$1" && cd "$1"; }

# trash: Moves a file to trash (cross-platform)
trash() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        command mv "$@" ~/.Trash
    else
        # Linux: use XDG trash or trash-cli if available
        if command -v trash-put >/dev/null 2>&1; then
            trash-put "$@"
        else
            mkdir -p ~/.local/share/Trash/files
            mv "$@" ~/.local/share/Trash/files/
        fi
    fi
}

# ql: Opens file in preview (macOS Quicklook / Linux xdg-open)
ql() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        qlmanage -p "$*" >& /dev/null
    else
        xdg-open "$@" >& /dev/null &
    fi
}

# cleands: Recursively delete .DS_Store files
cleands () { find . -type f -name '*.DS_Store' -ls -delete; }

# To create a ZIP archive of a folder
zipf () { zip -r "$1".zip "$1" ; }

# 'Cd's to frontmost window of MacOS Finder (macOS only)
cdf() {
    if [[ "$OSTYPE" != "darwin"* ]]; then
        echo "cdf: Only available on macOS"
        return 1
    fi
    currFolderPath=$( /usr/bin/osascript <<EOT
        tell application "Finder"
            try
        set currFolder to (folder of the front window as alias)
            on error
        set currFolder to (path to desktop folder as alias)
            end try
            POSIX path of currFolder
        end tell
EOT
    )
    echo "cd to \"$currFolderPath\""
    cd "$currFolderPath"
}

# Search for a file (macOS Spotlight / Linux locate+find)
spotlight() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        mdfind "kMDItemDisplayName == '$@'wc"
    else
        locate -i "$@" 2>/dev/null || find / -iname "*$@*" 2>/dev/null | head -20
    fi
}

# Useful information
ii() {
    echo -e "\nYou are logged on ${RED}$HOST"
    echo -e "\nAdditionnal information:$NC " ; uname -a
    echo -e "\n${RED}Users logged on:$NC " ; w -h
    echo -e "\n${RED}Current date :$NC " ; date
    echo -e "\n${RED}Machine stats :$NC " ; uptime
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo -e "\n${RED}Current network location :$NC " ; scselect
    fi
    echo -e "\n${RED}Public facing IP Address :$NC " ; myip
    echo
}

# kia: Gracefully terminate all processes matching given name
kia () { killall "$@"; }

# kiaf: Force kill all processes matching given name (using SIGKILL)
kiaf () { killall -9 "$@"; }

# Global updater
up() {
    # Password for Sudo
    echo -e "\033[0;36mPlease provide local password (may auto-skip)...\033[0m"
    sudo -v

    # Keep sudo alive
    while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

    echo -e "\nðŸ”„ Starting system update...\n"

    # Track failures
    declare -a failed_updates=()

    # Mac Updates
    if [ "$(uname)" = "Darwin" ]; then
        echo "ðŸ“± Checking for macOS updates..."
        if sudo softwareupdate -i -a; then
            echo "âœ… macOS updates complete"
        else
            failed_updates+=("macOS")
        fi
    fi

    # Homebrew
    if command -v brew &> /dev/null; then
        echo "ðŸº Updating Homebrew packages..."
        if brew update && \
           brew upgrade && \
           brew upgrade --cask && \
           brew cleanup && \
           brew doctor; then
            echo "âœ… Homebrew updates complete"
        else
            failed_updates+=("Homebrew")
        fi
    fi

    # NPM
    if command -v npm &> /dev/null; then
        echo "ðŸ“¦ Updating NPM..."
        if npm install -g npm@latest && \
           npm update -g; then
            echo "âœ… NPM updates complete"
        else
            failed_updates+=("NPM")
        fi
    fi

    # PNPM
    if command -v pnpm &> /dev/null; then
        echo "ðŸ“¦ Updating PNPM..."
        if pnpm update -g; then
            echo "âœ… PNPM updates complete"
        else
            failed_updates+=("PNPM")
        fi
    fi

    # Yarn
    if command -v yarn &> /dev/null; then
        echo "ðŸ§¶ Updating Yarn..."
        local yarn_update_success=true
        local yarn_version
        yarn_version=$(yarn --version 2>/dev/null)

        if [[ $yarn_version == 1.* ]]; then
            if command -v npm &> /dev/null; then
                if ! npm install -g yarn@latest --no-audit --no-fund; then
                    yarn_update_success=false
                fi
            else
                yarn_update_success=false
            fi
            if $yarn_update_success; then
                if ! yarn global upgrade; then
                    yarn_update_success=false
                fi
            fi
        else
            if command -v corepack &> /dev/null; then
                if ! COREPACK_ENABLE_DOWNLOAD_PROMPT=0 corepack prepare yarn@stable --activate; then
                    yarn_update_success=false
                fi
            else
                yarn_update_success=false
            fi
        fi

        if $yarn_update_success; then
            echo "âœ… Yarn updates complete"
        else
            failed_updates+=("Yarn")
        fi
    fi

    # Python pip
    if command -v pip &> /dev/null; then
        echo "ðŸ Updating Python packages..."
        local pip_update_success=true
        if ! pip install --upgrade pip setuptools wheel; then
            pip_update_success=false
        fi
        if $pip_update_success; then
            local pip_python
            pip_python=$(command -v python3 || command -v python || true)
            if [[ -z "$pip_python" ]]; then
                pip_update_success=false
            else
                local outdated_json
                if outdated_json=$(pip list --outdated --format=json 2>/dev/null); then
                    if [[ "$outdated_json" != "[]" ]]; then
                        local pip_outdated_packages
                        if pip_outdated_packages=$("$pip_python" -c 'import json, sys
try:
    data = sys.stdin.read()
    if not data.strip():
        sys.exit(0)
    entries = json.loads(data)
except Exception:
    sys.exit(1)
names = [item.get("name") for item in entries if isinstance(item, dict) and item.get("name")]
sys.stdout.write("\n".join(names))
' <<< "$outdated_json"); then
                            if [[ -n "$pip_outdated_packages" ]]; then
                                while IFS= read -r pkg; do
                                    [[ -z "$pkg" ]] && continue
                                    if ! pip install -U "$pkg"; then
                                        pip_update_success=false
                                        break
                                    fi
                                done <<< "$pip_outdated_packages"
                            fi
                        else
                            pip_update_success=false
                        fi
                    fi
                else
                    pip_update_success=false
                fi
            fi
        fi
        if $pip_update_success; then
            echo "âœ… Python packages updated"
        else
            failed_updates+=("Python pip")
        fi
    fi

    # Python pip3
    if command -v pip3 &> /dev/null; then
        echo "ðŸ Updating Python3 packages..."
        local pip3_update_success=true
        if ! pip3 install --upgrade pip setuptools wheel; then
            pip3_update_success=false
        fi
        if $pip3_update_success; then
            local pip3_python
            pip3_python=$(command -v python3 || command -v python || true)
            if [[ -z "$pip3_python" ]]; then
                pip3_update_success=false
            else
                local outdated3_json
                if outdated3_json=$(pip3 list --outdated --format=json 2>/dev/null); then
                    if [[ "$outdated3_json" != "[]" ]]; then
                        local pip3_outdated_packages
                        if pip3_outdated_packages=$("$pip3_python" -c 'import json, sys
try:
    data = sys.stdin.read()
    if not data.strip():
        sys.exit(0)
    entries = json.loads(data)
except Exception:
    sys.exit(1)
names = [item.get("name") for item in entries if isinstance(item, dict) and item.get("name")]
sys.stdout.write("\n".join(names))
' <<< "$outdated3_json"); then
                            if [[ -n "$pip3_outdated_packages" ]]; then
                                while IFS= read -r pkg; do
                                    [[ -z "$pkg" ]] && continue
                                    if ! pip3 install -U "$pkg"; then
                                        pip3_update_success=false
                                        break
                                    fi
                                done <<< "$pip3_outdated_packages"
                            fi
                        else
                            pip3_update_success=false
                        fi
                    fi
                else
                    pip3_update_success=false
                fi
            fi
        fi
        if $pip3_update_success; then
            echo "âœ… Python3 packages updated"
        else
            failed_updates+=("Python pip3")
        fi
    fi

    # Ruby Gems
    if command -v gem &> /dev/null; then
        echo "ðŸ’Ž Updating Ruby Gems..."
        if sudo gem update --system --no-document && \
           sudo gem update --no-document && \
           sudo gem cleanup; then
            echo "âœ… Ruby Gems updated"
        else
            failed_updates+=("Ruby Gems")
        fi
    fi

    # Rust
    if command -v rustup &> /dev/null; then
        echo "ðŸ¦€ Updating Rust..."
        if rustup update; then
            echo "âœ… Rust updated"
        else
            failed_updates+=("Rust")
        fi
    fi

    # Cargo
    if command -v cargo &> /dev/null; then
        echo "ðŸ“¦ Updating Cargo packages..."
        if cargo install-update -a; then
            echo "âœ… Cargo packages updated"
        else
            failed_updates+=("Cargo")
        fi
    fi

    # Composer
    if command -v composer &> /dev/null; then
        echo "ðŸŽ¼ Updating Composer packages..."
        if composer self-update && \
           composer global update; then
            echo "âœ… Composer packages updated"
        else
            failed_updates+=("Composer")
        fi
    fi

    # Go packages
    if command -v go &> /dev/null; then
        echo "ðŸ¹ Updating Go packages..."
        if go get -u all; then
            echo "âœ… Go packages updated"
        else
            failed_updates+=("Go")
        fi
    fi

    # Deno
    if command -v deno &> /dev/null; then
        echo "ðŸ¦• Updating Deno..."
        if deno upgrade; then
            echo "âœ… Deno updated"
        else
            failed_updates+=("Deno")
        fi
    fi

    # Bun
    if command -v bun &> /dev/null; then
        echo "ðŸ¥Ÿ Updating Bun..."
        if bun upgrade; then
            echo "âœ… Bun updated"
        else
            failed_updates+=("Bun")
        fi
    fi

    # Flutter
    if command -v flutter &> /dev/null; then
        echo "ðŸ“± Updating Flutter..."
        if flutter upgrade && \
           flutter pub get; then
            echo "âœ… Flutter updated"
        else
            failed_updates+=("Flutter")
        fi
    fi

    # Update locate database
    if command -v updatedb &> /dev/null; then
        echo "ðŸ” Updating locate database..."
        if sudo updatedb 2> /dev/null; then
            echo "âœ… Locate database updated"
        else
            failed_updates+=("updatedb")
        fi
    fi

    # TLDR pages
    if command -v tldr &> /dev/null; then
        echo "ðŸ“š Updating TLDR pages..."
        if tldr --update; then
            echo "âœ… TLDR pages updated"
        else
            failed_updates+=("TLDR")
        fi
    fi

    # Final status report
    echo -e "\nðŸ“‹ Update Summary:"
    if [ ${#failed_updates[@]} -eq 0 ]; then
        echo -e "\nâœ… All updates completed successfully!\n"
    else
        echo -e "\nâš ï¸  The following updates had issues:"
        printf '%s\n' "${failed_updates[@]}"
        echo -e "\nAll other updates completed successfully.\n"
    fi

    # Optional: Clean up system
    echo "ðŸ§¹ Cleaning up system..."
    if [ "$(uname)" = "Darwin" ]; then
        sudo rm -rf /private/var/log/asl/*.asl
        sudo rm -rf ~/Library/Caches/*
        sudo rm -rf ~/Library/Logs/*
    fi

    # Clear DNS cache
    if [ "$(uname)" = "Darwin" ]; then
        sudo dscacheutil -flushcache
        sudo killall -HUP mDNSResponder
    fi

    # Mole cleanup (macOS only)
    if [ "$(uname)" = "Darwin" ] && command -v mole &> /dev/null; then
        echo "ðŸ¾ Running Mole clean..."
        if ! mole clean; then
            failed_updates+=("Mole")
        fi
    fi

    echo -e "\nâœ¨ System update and cleanup complete!\n"
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! $(uname -s) = 'Darwin' ]; then
    if grep -q Microsoft /proc/version; then
        # Ubuntu on Windows using the Linux subsystem
        alias open='explorer.exe';
    else
        alias open='xdg-open';
    fi
fi

# Create a data URL from a file
dataurl() {
    local mimeType
    mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Call from a local repo to open the repository on github/bitbucket in browser
# Modified version of https://github.com/zeke/ghwd
repo() {
    # Figure out github repo base URL
    local base_url
    base_url=$(git config --get remote.origin.url)
    base_url=${base_url%\.git} # remove .git from end of string

    # Fix git@github.com: URLs
    base_url=${base_url//git@github\.com:/https:\/\/github\.com\/}

    # Fix git://github.com URLS
    base_url=${base_url//git:\/\/github\.com/https:\/\/github\.com\/}

    # Fix git@bitbucket.org: URLs
    base_url=${base_url//git@bitbucket.org:/https:\/\/bitbucket\.org\/}

    # Fix git@gitlab.com: URLs
    base_url=${base_url//git@gitlab\.com:/https:\/\/gitlab\.com\/}

    # Validate that this folder is a git folder
    if ! git branch 2>/dev/null 1>&2 ; then
        echo "Not a git repo!"
        exit $?
    fi

    # Find current directory relative to .git parent
    full_path=$(pwd)
    git_base_path=$(cd "./$(git rev-parse --show-cdup)" || exit 1; pwd)
    relative_path=${full_path#$git_base_path} # remove leading git_base_path from working directory

    # If filename argument is present, append it
    if [ "$1" ]; then
        relative_path="$relative_path/$1"
    fi

    # Figure out current git branch
    # git_where=$(command git symbolic-ref -q HEAD || command git name-rev --name-only --no-undefined --always HEAD) 2>/dev/null
    git_where=$(command git name-rev --name-only --no-undefined --always HEAD) 2>/dev/null

    # Remove cruft from branchname
    branch=${git_where#refs\/heads\/}
    branch=${branch#remotes\/origin\/}

    [[ $base_url == *bitbucket* ]] && tree="src" || tree="tree"
    url="$base_url/$tree/$branch$relative_path"


    echo "Calling $(type open) for $url"

    open "$url" &> /dev/null || (echo "Using $(type open) to open URL failed." && exit 1);
}

# Run diagnostics on all available package managers and development tools
function doctor() {
    echo -e "\nðŸ¥ Starting system diagnostics...\n"

    # Track issues
    declare -a found_issues=()

    # Homebrew
    if command -v brew &> /dev/null; then
        echo "ðŸº Running Homebrew diagnostics..."
        if ! brew doctor; then
            found_issues+=("Homebrew")
        fi
    fi

    # Ruby environment
    if command -v rbenv &> /dev/null; then
        echo "ðŸ’Ž Checking Ruby environment..."
        if ! curl -fsSL https://github.com/rbenv/rbenv-installer/raw/main/bin/rbenv-doctor | bash; then
            found_issues+=("Ruby/rbenv")
        fi
    fi

    # Node environment
    if command -v npm &> /dev/null; then
        echo "ðŸ“¦ Checking NPM..."
        if ! npm doctor; then
            found_issues+=("NPM")
        fi
    fi

    # Yarn
    if command -v yarn &> /dev/null; then
        echo "ðŸ§¶ Checking Yarn..."
        local yarn_ok=true
        if ! yarn --version > /dev/null 2>&1; then
            if command -v corepack &> /dev/null; then
                if env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 corepack prepare yarn@stable --activate > /dev/null 2>&1; then
                    yarn --version > /dev/null 2>&1 || yarn_ok=false
                else
                    yarn_ok=false
                fi
            else
                yarn_ok=false
            fi
        fi
        if $yarn_ok && yarn help doctor > /dev/null 2>&1; then
            if ! env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 yarn doctor > /dev/null 2>&1; then
                yarn_ok=false
            fi
        fi
        if ! $yarn_ok; then
            found_issues+=("Yarn")
        fi
    fi

    # PNPM
    if command -v pnpm &> /dev/null; then
        echo "ðŸ“¦ Checking PNPM..."
        local pnpm_ok=true
        if ! env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 pnpm --version > /dev/null 2>&1; then
            if command -v corepack &> /dev/null; then
                if env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 corepack prepare pnpm@latest --activate > /dev/null 2>&1; then
                    env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 pnpm --version > /dev/null 2>&1 || pnpm_ok=false
                else
                    pnpm_ok=false
                fi
            else
                pnpm_ok=false
            fi
        fi
        if $pnpm_ok && command -v pnpm &> /dev/null; then
            if ! env COREPACK_ENABLE_DOWNLOAD_PROMPT=0 pnpm doctor > /dev/null 2>&1; then
                pnpm_ok=false
            fi
        fi
        if ! $pnpm_ok; then
            found_issues+=("PNPM")
        fi
    fi

    # Python environment
    if command -v pip &> /dev/null; then
        echo "ðŸ Checking pip..."
        if ! pip check; then
            found_issues+=("Python pip dependencies")
        fi
    fi

    # Flutter
    if command -v flutter &> /dev/null; then
        echo "ðŸ“± Checking Flutter..."
        if ! flutter doctor; then
            found_issues+=("Flutter")
        fi
    fi

    # Git
    if command -v git &> /dev/null; then
        echo "ðŸŒ¿ Checking Git configuration..."
        if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
            if ! git fsck > /dev/null 2>&1; then
                found_issues+=("Git repository integrity")
            fi
        else
            echo "Skipping git fsck (not inside a repository)."
        fi
    fi

    # Docker
    if command -v docker &> /dev/null; then
        echo "ðŸ³ Checking Docker..."
        if ! docker info > /dev/null 2>&1; then
            found_issues+=("Docker")
        fi
    fi

    # Composer
    if command -v composer &> /dev/null; then
        echo "ðŸŽ¼ Checking Composer..."
        if ! composer diagnose; then
            found_issues+=("Composer")
        fi
    fi

    # System integrity (macOS only)
    if [ "$(uname)" == "Darwin" ]; then
        echo "ðŸŽ Checking macOS system integrity..."
        if ! system_profiler SPSoftwareDataType > /dev/null; then
            found_issues+=("macOS System")
        fi

        if command -v verify_system > /dev/null 2>&1; then
            echo "ðŸ” Verifying system integrity..."
            if sudo -n true 2>/dev/null; then
                if ! sudo verify_system > /dev/null 2>&1; then
                    found_issues+=("macOS System Integrity")
                fi
            else
                echo "Skipping verify_system (sudo password required)."
            fi
        fi
    fi

    # Disk health (macOS only)
    if [ "$(uname)" == "Darwin" ] && command -v diskutil > /dev/null 2>&1; then
        echo "ðŸ’½ Checking disk health..."
        if ! diskutil verifyVolume / > /dev/null 2>&1; then
            found_issues+=("Disk health")
        fi
    fi

    # Network diagnostics
    echo "ðŸŒ Checking network connectivity..."
    if ! ping -c 1 8.8.8.8 > /dev/null 2>&1; then
        found_issues+=("Network connectivity")
    fi

    # DNS resolution
    if ! nslookup github.com > /dev/null 2>&1; then
        found_issues+=("DNS resolution")
    fi

    # Mole cleanup (macOS only)
    if [ "$(uname)" == "Darwin" ] && command -v mole &> /dev/null; then
        echo "ðŸ¾ Running Mole clean..."
        if ! mole clean; then
            found_issues+=("Mole clean")
        fi
    fi

    # iCloud sync health (macOS only)
    if [ "$(uname)" == "Darwin" ]; then
        local icloud_dir="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
        if [[ -d "$icloud_dir" ]]; then
            echo "â˜ï¸  Checking iCloud sync health..."
            local bad_folders=0
            local patterns=(".venv" "venv" "__pycache__" "node_modules" ".next" "dist" "build" ".cache")
            for pattern in "${patterns[@]}"; do
                local count=$(find "$icloud_dir" -maxdepth 4 -type d -name "$pattern" 2>/dev/null | wc -l | tr -d ' ')
                if [[ "$count" -gt 0 ]]; then
                    echo "   âš ï¸  Found $count '$pattern' folder(s) syncing to iCloud"
                    bad_folders=$((bad_folders + count))
                fi
            done
            if [[ "$bad_folders" -gt 0 ]]; then
                found_issues+=("iCloud syncing dev folders")
                echo "   ðŸ’¡ Run 'icloud-ignore' to exclude dev folders from sync"
            else
                echo "   âœ… No dev folders detected in iCloud (shallow scan)"
            fi
        fi
    fi

    # Final report
    echo -e "\nðŸ“‹ Diagnostic Summary:"
    if [ ${#found_issues[@]} -eq 0 ]; then
        echo -e "\nâœ… All systems are running normally!\n"
    else
        echo -e "\nâš ï¸  Issues were found in the following systems:"
        printf '%s\n' "${found_issues[@]}"
        echo -e "\nPlease review the output above for detailed information about each issue.\n"
    fi

    # Suggestions for fixes
    if [ ${#found_issues[@]} -gt 0 ]; then
        echo "ðŸ”§ Suggested fixes:"
        echo "1. For Homebrew issues: 'brew doctor'"
        echo "2. For Ruby issues: 'rbenv doctor'"
        echo "3. For Node issues: 'npm doctor'"
        echo "4. For Flutter issues: 'flutter doctor'"
        echo "5. For disk issues: 'diskutil repairVolume /'"
        echo "6. For package manager issues: Try running 'up' to update all packages"
        echo -e "\n"
    fi
}

# Extract most known archives with one command
extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)          echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Create a .tar.gz archive using `zlib` compression
targz() {
    local tmpFile="${1%/}.tar"
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${1}" || return 1
    # BSD stat (macOS) vs GNU stat (Linux)
    if [[ "$OSTYPE" == "darwin"* ]]; then
        size=$(stat -f"%z" "${tmpFile}" 2>/dev/null)
    else
        size=$(stat -c%s "${tmpFile}" 2>/dev/null)
    fi
    gzip -9 "${tmpFile}" || return 1
    echo "Created archive $(du -h ${tmpFile}.gz)"
}
